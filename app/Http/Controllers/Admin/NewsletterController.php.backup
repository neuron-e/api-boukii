<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\AppBaseController;
use App\Models\Newsletter;
use App\Models\Client;
use App\Models\School;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Facades\Validator;
use Illuminate\Support\Facades\Mail;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Carbon\Carbon;
use AppMailNewsletterMailer;

class NewsletterController extends AppBaseController
{
    /**
     * Test endpoint to verify functionality
     */
    public function test(): JsonResponse
    {
        return response()->json([
            'success' => true,
            'message' => 'Newsletter controller is working!',
            'timestamp' => now()
        ]);
    }

    /**
     * Get newsletter statistics for dashboard
     */
    public function stats(Request $request): JsonResponse
    {
        $school = $this->getSchool($request);

        // Total subscribers (clients that accept newsletter)
        $totalSubscribers = Client::where('user_id', $school->user_id)
            ->where('accepts_newsletter', true)
            ->count();

        // Total sent newsletters
        $totalSent = Newsletter::forSchool($school->id)
            ->where('status', 'sent')
            ->count();

        // Average open rate from all sent newsletters
        $averageOpenRate = Newsletter::forSchool($school->id)
            ->where('status', 'sent')
            ->where('sent_count', '>', 0)
            ->selectRaw('AVG(opened_count / sent_count * 100) as avg_rate')
            ->value('avg_rate') ?? 0;

        $stats = [
            'total_subscribers' => $totalSubscribers,
            'total_sent' => $totalSent,
            'open_rate' => round($averageOpenRate, 1),
        ];

        return $this->sendResponse($stats, 'Newsletter stats retrieved successfully');
    }

    /**
     * Get recent newsletters
     */
    public function recent(Request $request): JsonResponse
    {
        $school = $this->getSchool($request);

        $newsletters = Newsletter::forSchool($school->id)
            ->with('user:id,first_name,last_name')
            ->recent(10)
            ->get()
            ->map(function ($newsletter) {
                return [
                    'id' => $newsletter->id,
                    'subject' => $newsletter->subject,
                    'content' => $newsletter->content,
                    'recipients' => $newsletter->total_recipients,
                    'sent_date' => $newsletter->sent_at,
                    'status' => $newsletter->status,
                    'open_rate' => $newsletter->open_rate,
                    'created_by' => $newsletter->user->first_name . ' ' . $newsletter->user->last_name,
                ];
            });

        return $this->sendResponse($newsletters, 'Recent newsletters retrieved successfully');
    }

    /**
     * Get all newsletters with pagination
     */
    public function index(Request $request): JsonResponse
    {
        $school = $this->getSchool($request);
        
        $page = $request->get('page', 1);
        $perPage = $request->get('per_page', 10);
        $status = $request->get('status');

        $query = Newsletter::forSchool($school->id)->with('user:id,first_name,last_name');

        if ($status) {
            $query->byStatus($status);
        }

        $newsletters = $query->orderBy('created_at', 'desc')
            ->paginate($perPage, ['*'], 'page', $page);

        return $this->sendResponse($newsletters, 'Newsletters retrieved successfully');
    }

    /**
     * Store a new newsletter
     */
    public function store(Request $request): JsonResponse
    {
        $validator = Validator::make($request->all(), [
            'subject' => 'required|string|max:255',
            'content' => 'required|string',
            'recipients' => 'required|array|min:1',
            'template_type' => 'nullable|string|in:welcome,promotion,newsletter,event',
            'scheduled_at' => 'nullable|date|after:now',
        ]);

        if ($validator->fails()) {
            return $this->sendError('Validation Error', $validator->errors(), 400);
        }

        $school = $this->getSchool($request);
        $user = $request->user();

        // Calculate total recipients
        $totalRecipients = $this->calculateRecipients($school->id, $request->recipients);

        $newsletter = Newsletter::create([
            'school_id' => $school->id,
            'user_id' => $user->id,
            'subject' => $request->subject,
            'content' => $request->content,
            'recipients_config' => $request->recipients,
            'total_recipients' => $totalRecipients,
            'template_type' => $request->template_type,
            'scheduled_at' => $request->scheduled_at,
            'status' => $request->scheduled_at ? 'scheduled' : 'draft',
            'metadata' => $request->metadata ?? [],
        ]);

        return $this->sendResponse($newsletter, 'Newsletter created successfully', 201);
    }

    /**
     * Show a specific newsletter
     */
    public function show(Request $request, $id): JsonResponse
    {
        $school = $this->getSchool($request);

        $newsletter = Newsletter::forSchool($school->id)
            ->with('user:id,first_name,last_name')
            ->find($id);

        if (!$newsletter) {
            return $this->sendError('Newsletter not found', [], 404);
        }

        return $this->sendResponse($newsletter, 'Newsletter retrieved successfully');
    }

    /**
     * Update a newsletter
     */
    public function update(Request $request, $id): JsonResponse
    {
        $validator = Validator::make($request->all(), [
            'subject' => 'required|string|max:255',
            'content' => 'required|string',
            'recipients' => 'required|array|min:1',
            'template_type' => 'nullable|string|in:welcome,promotion,newsletter,event',
            'scheduled_at' => 'nullable|date|after:now',
        ]);

        if ($validator->fails()) {
            return $this->sendError('Validation Error', $validator->errors(), 400);
        }

        $school = $this->getSchool($request);

        $newsletter = Newsletter::forSchool($school->id)->find($id);

        if (!$newsletter) {
            return $this->sendError('Newsletter not found', [], 404);
        }

        // Only allow updates on drafts and scheduled newsletters
        if (!in_array($newsletter->status, ['draft', 'scheduled'])) {
            return $this->sendError('Cannot update a newsletter that has been sent', [], 400);
        }

        // Recalculate recipients
        $totalRecipients = $this->calculateRecipients($school->id, $request->recipients);

        $newsletter->update([
            'subject' => $request->subject,
            'content' => $request->content,
            'recipients_config' => $request->recipients,
            'total_recipients' => $totalRecipients,
            'template_type' => $request->template_type,
            'scheduled_at' => $request->scheduled_at,
            'status' => $request->scheduled_at ? 'scheduled' : 'draft',
            'metadata' => $request->metadata ?? $newsletter->metadata,
        ]);

        return $this->sendResponse($newsletter, 'Newsletter updated successfully');
    }

    /**
     * Delete a newsletter
     */
    public function destroy(Request $request, $id): JsonResponse
    {
        $school = $this->getSchool($request);

        $newsletter = Newsletter::forSchool($school->id)->find($id);

        if (!$newsletter) {
            return $this->sendError('Newsletter not found', [], 404);
        }

        // Only allow deletion of drafts
        if ($newsletter->status !== 'draft') {
            return $this->sendError('Cannot delete a newsletter that is not a draft', [], 400);
        }

        $newsletter->delete();

        return $this->sendResponse(null, 'Newsletter deleted successfully');
    }

    /**
     * Send newsletter immediately
     */
    public function send(Request $request, $id): JsonResponse
    {
        $school = $this->getSchool($request);

        $newsletter = Newsletter::forSchool($school->id)->find($id);

        if (!$newsletter) {
            return $this->sendError('Newsletter not found', [], 404);
        }

        if (!in_array($newsletter->status, ['draft', 'scheduled'])) {
            return $this->sendError('Newsletter cannot be sent', [], 400);
        }

        try {
            // Update status to sending
            $newsletter->update(['status' => 'sending']);

            // Get recipients
            $recipients = $this->getRecipients($school->id, $newsletter->recipients_config);

            // Send emails
            $sentCount = $this->sendNewsletterEmails($newsletter, $recipients);

            // Update newsletter with results
            $newsletter->update([
                'status' => 'sent',
                'sent_at' => now(),
                'sent_count' => $sentCount,
                'delivered_count' => $sentCount, // Assume all delivered for now
            ]);

            return $this->sendResponse($newsletter, 'Newsletter sent successfully');

        } catch (\Exception $e) {
            Log::error('Newsletter sending failed: ' . $e->getMessage());
            
            $newsletter->update(['status' => 'failed']);

            return $this->sendError('Failed to send newsletter', ['error' => $e->getMessage()], 500);
        }
    }

    /**
     * Get subscriber count for specific recipient configuration
     */
    public function subscriberCount(Request $request): JsonResponse
    {
        $validator = Validator::make($request->all(), [
            'recipients' => 'required|array|min:1',
        ]);

        if ($validator->fails()) {
            return $this->sendError('Validation Error', $validator->errors(), 400);
        }

        $school = $this->getSchool($request);
        $count = $this->calculateRecipients($school->id, $request->recipients);

        return $this->sendResponse(['count' => $count], 'Subscriber count calculated');
    }

    /**
     * Get list of subscribers
     */
    public function subscribers(Request $request): JsonResponse
    {
        $school = $this->getSchool($request);

        $subscribers = Client::query()
            ->join('clients_schools', 'clients_schools.client_id', '=', 'clients.id')
            ->where('clients_schools.school_id', $school->id)
            ->where('clients_schools.accepts_newsletter', true)
            ->select('clients.id', 'clients.first_name', 'clients.last_name', 'clients.email', 'clients.created_at')
            ->distinct()
            ->paginate($request->get('per_page', 50));

        return $this->sendResponse($subscribers, 'Subscribers retrieved successfully');
    }

    // Private helper methods

    private function calculateRecipients($schoolId, $recipientConfig): int
    {
        $recipients = $this->getRecipients($schoolId, $recipientConfig);
        return $recipients->count();
    }

    private function getRecipients($schoolId, $recipientConfig)
    {
        $school = School::find($schoolId);
        $query = Client::query()
            ->join('clients_schools', 'clients_schools.client_id', '=', 'clients.id')
            ->where('clients_schools.school_id', $school->id)
            ->where('clients_schools.accepts_newsletter', true);

        foreach ($recipientConfig as $type) {
            switch ($type) {
                case 'all':
                    // No additional filtering
                    break;
                case 'active':
                    // Clients with recent bookings (last 6 months)
                    $query->whereHas('bookingUsers', function ($q) {
                        $q->where('created_at', '>=', Carbon::now()->subMonths(6));
                    });
                    break;
                case 'inactive':
                    // Clients without recent bookings
                    $query->whereDoesntHave('bookingUsers', function ($q) {
                        $q->where('created_at', '>=', Carbon::now()->subMonths(6));
                    });
                    break;
                case 'vip':
                    // VIP clients (per school)
                    $query->where('clients_schools.is_vip', true);
                    break;
            }
        }

        return $query->select('clients.*')->distinct();
    }

    private function sendNewsletterEmails($newsletter, $recipients): int
    {
        $sentCount = 0;

        foreach ($recipients->get() as $recipient) {
            try {
                // Determine locale for recipient (fallback to app locale)
                $recipient->loadMissing('language1', 'language2', 'language3');
                $locale = ($recipient->language1?->code)
                    ?? ($recipient->language2?->code)
                    ?? ($recipient->language3?->code)
                    ?? config('app.locale', 'en');

                app()->setLocale($locale);

                // Send the actual email
                Mail::send('emails.newsletter', [
                    'content' => $newsletter->content,
                    'subject' => $newsletter->subject,
                    'client' => $recipient,
                    'newsletter' => $newsletter,
                    'locale' => $locale,
                ], function ($message) use ($recipient, $newsletter) {
                    $message->to($recipient->email, $recipient->first_name . ' ' . $recipient->last_name)
                            ->subject($newsletter->subject)
                            ->from(config('mail.from.address'), config('mail.from.name'));
                });

                $sentCount++;
            } catch (\Exception $e) {
                Log::error("Failed to send newsletter to {$recipient->email}: " . $e->getMessage());
            }
        }

        return $sentCount;
    }

}
